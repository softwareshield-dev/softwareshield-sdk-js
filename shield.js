var Shield = function () {
    var _nonce = 0;

    var _shield = null;
    try {
        _shield = gs;
    } catch (ex) {
        alert(ex);
    };

    if (!_shield) {
        throw 'Failed to Load GS 5';
    }

     /**
      * Initialize server list
      * 
      * Normally the server list is specified in file ("UI_HTML/js/GS_Mapping.js") generated by IDE.
      * 
      * Now it supports environment variable and built-in servers in case server settings is not found.
      * 
      */
     function InitServers(){
       if(gs){
          var srv = gs.os.getEnvironmentVariable('GS5_CHECKPOINT_SERVER'); 
          //console.log('GS5_CHECKPOINT_SERVER => ' + srv);
          if(srv){
            checkPointServers = []; //override existent settings
            checkPointServers[0] = {
              Name: 'server_0',
              URL: srv + '/checkpoint2/CheckPointService.svc/GenerateResponseCode?callback=?',
              Tries: 0,
              MaxTries: 5,
              TimeOut: 15000
            }

            return;
          } 
       } 
       
       if(typeof checkPointServers === 'undefined'){
            //UI_HTML/js/GS_Mapping.js is missing, fall backs to built-in servers
            checkPointServers = [];
            ['https://shield.yummy.net', 'https://secure.yummy.net'].forEach(function(srv, i){
              checkPointServers.push({
                    Name: 'server_' + i,
                    URL: srv + '/checkpoint2/CheckPointService.svc/GenerateResponseCode?callback=?',
                    Tries: 0,
                    MaxTries: 5,
                    TimeOut: 15000
                  });
            });
       }
     }

    return {
        CheckPointActivationType: function () {
            return {
                Unlock: 0,
                Revoke: 1,
                ValidateSN: 2
            }
        }(),

        CheckPointFunction: function () {
            return {
                GenerateResponseCode: "GenerateResponseCode",
                ValidateSN: "ValidateSerialNumber"
            }
        }(),

        CheckPointResponse: function () {
            return {
                InvalidSerialNumber: 0,
                NoActivationsRemaining: 1,
                CodeGenerated: 2,
                FormatOK: 3,
                InvalidRequestCode: 4,
                KeyGenError: 5,
                CodeBadFormat: 10,
                InternalFailure: 18,
                GetSNFailure: 61,
                GetSNSuccess: 62,
                InvalidProduct: 82,
                RevokeReceiptAccepted: 100,
                RevokeInvalidReceipt: 101,
                RevokeInvalidSerialNumber: 102,
                RevokeReactivationToleranceExceeded: 103
            }
        }(),

        LicenseModel: function () {
            return {
                ExpireByDuration: "gs.lm.expire.duration.1",
                ExpireByAccessTimes: "gs.lm.expire.accessTime.1",
                ExpireBySessionTime: "gs.lm.expire.sessionTime.1",
                ExpireByHardDate: "gs.lm.expire.hardDate.1",
                ExpireByPeriod: "gs.lm.expire.period.1",
                AlwaysLock: "gs.lm.alwaysLock.1",
                AlwaysRun: "gs.lm.alwaysRun.1"
            }
        }(),


        Debug: function () {
            var _debug = _shield.sessionData.getVar('debug');
            if (_debug === null) {
                return false;
            } else {
                return true;
            }
        },

        /**
         *
         * Sets the debug value. If true, add the logger to the body element and log
         *
         * @param {bool} set the debug value
         */
        SetDebug: function (isDebug) {
            _shield.sessionData.setVar('debug', isDebug);
            // if (isDebug === true) {
            //     if ($('#DebugLog').length === 0) {
            //         var logList = $('<ul class="unstyled" id="DebugLog"></ul>');
            //         $('body').append(logList);
            //     }
            // }
        },


        /**
         *
         * Logs into the console. If Shield.Debug() is true, add stack trace
         *
         * @param {string} the log message
         * @param {bool} if true, write the message as an error in the console.
         */
        Log: function (logMessage, isError) {
            console.log((isError ? '!ERR: ' : '') + logMessage);
        },


        /**
         * Returns the version of Shield used
         * @return {String} Version of Shield
         *
         */
        GameShieldVersion: function () {
            return _shield.version;
        },

        /**
         * Returns the version of Shield used
         * @return {String} Version of Shield
         *
         */
        Version: function () {
            return _shield.version;
        },

        /**
         * Returns Product Name
         * @return {String} Product name
         *
         */
        ProductName: function () {
            return _shield.productName;
        },

        /**
         * Returns the Product ID of the project
         * @return {String} Product ID
         *
         */
        ProductId: function () {
            return _shield.productId;
        },

        /**
         * Returns true if all Entities are Licensed
         * @return {bool} if all Entities are Fully Licensed
         *
         */
        IsFullyRegistered: function () {
            for (var i = 0; i < _shield.core.getTotalEntityCount() ; ++i) {
                if (!_shield.core.getEntityByIndex(i).isFullyLicensed()) {
                    return false;
                }
            }
            return true;
        },
 
        IsRegistered: function () {
            return Shield.Entities.GetCurrentEntity().isFullyLicensed();
        },

        /**
         *
         *Returns the current entity's license
         *
         * @return {license} Current Entity's License
         */
        GetCurrentLicense: function () {
            if (_shield.core.getCurrentEntityId() == '(unknown)') {
                return gs.single.getLicense();
            } else {
                return _shield.core.getCurrentEntity().getLicenseByIndex(0);
            }
        },

        /**
         * Get the Unlock Request Code for the current entity
         *
         *
         * @return {string}  Unlock Request Code for the current entity
         */
        RequestActivation: function () {
            var lic = Shield.GetCurrentLicense();
            return _shield.util.getUnlockRequestCode(lic) + ':' + _shield.buildId;
        },



        //Deprecated, please uses RequestErrorFix();
        RequestCleanMachine: function () {
          return this.RequestErrorFix();
            //return _shield.util.getCleanMachineRequestCode();
        },
        //Deprecated, please uses RequestErrorFix();
        RequestFingerprintFix: function () {
          return this.RequestErrorFix();
        },
		
        RequestErrorFix: function () {
            var request = _shield.core.createRequest();
            request.addAction(_shield.core.ACT_FIX, null);
            return request.getRequestCode();
        },

        /**
         * Launch the App
         *
         */
        Play: function () {
            _shield.app.play();
        },

        /**
         * Launch the App
         *
         */

        Launch: function () {
            _shield.app.play();
        },

        /**
         * Exit the App
         *
         */

        Close: function () {
            _shield.app.exit(0);
        },

        /**
         * Restart the App
         *
         */

        Restart: function () {
            _shield.app.restart();
        },

        /**
         * Launches the users' default browser with the given url
         *
         * @param {string} The url to open the browser with
         */
        LaunchDefaultBrowser: function (url) {
            gs.util.launchDefaultBrowser(url);
        },


        /**
         * Shows the Shield Window. Call this function to show the UI or hide it
         *
         * @param {bool} Show or hide the window
         */
        WindowVisible: function (visible) {
            if (visible) {
                _shield.ui.show();
            } else {
                _shield.ui.hide();
            }
        },

        Navigate: function () {
            document.location = $('#domain').val();
        },

        /**
         * Checks if the serial number is valid on the server
         *
         * @param {string} the user's serial
         * @param {function} the function to call if the serial is not valid
         * @param {function} function to call if the serial is valid
         *
         */

        ValidateSerial: function (serial, failFunction, successFunction) {
            if(Shield.InActivating) return;
            Shield.InActivating = true;

            var request = _shield.core.createRequest();
            request.addAction(_shield.core.ACT_DUMMY, null);
            var reqCode = request.getRequestCode();
            _nonce++;
            Shield.InternalActivate(reqCode, serial, failFunction, successFunction, Shield.CheckPointActivationType.ValidateSN, "ValidateSerialNumber");
        },

        /**
         * Revokes the current license. Will only be successful if the current license is activated
         *
         * @param {string} the user's serial
         * @param {function} the function to call if revoke fails
         * @param {function} function to call if revoke is successful
         *
         */
        Revoke: function (serial, failFunction, successFunction) {
            setTimeout(function(){
              if(gs.core.revokeApp(serial)){
                successFunction();
              }else{
                failFunction({message: gs.core.getLastErrorMessage()});
              }
            }, 500);
       },


        /**
         * Tests the connection to the Activation servers
         *
         * @param {function} Function to call if the Ping was successful
         * @param {function} Function to call if the Ping was unsuccessful
         */
        Ping: function (successFunction, failedFunction) {
          Shield.InActivating = false;

          InitServers();
          Shield.PingParallel(successFunction, failedFunction);
        },

        /**
        * cb: function(err, {round_trip_time, max_process_time})
        */
        PingServer: function(srv, cb){
          var data = {
              productID: 'ping',
              serialNumber: '',
              requestCode: '',
              BuildId: -1
          }

          var dtStart = new Date();
  
          $.ajax({
              url: srv.URL,
              dataType: "jsonp",
              timeout: Math.max(+srv.TimeOut, Shield.max_checkpoint2_ping_time_out), //wait for 30 seconds in the worst case
              cache: false,
              data: data
          }).success(
              function (result) {
                console.log('PingServer success: result (' + JSON.stringify(result) + ')');

                if (result.err) {
                  cb(result.err, null);
                } else {
                  cb(null, {
                    clientIP: result.UserHostAddress,
                    round_trip_time: (new Date()).getTime() - dtStart.getTime(),
                    max_process_time: result.PerfData ? +result.PerfData.max_process_time : Shield.max_checkpoint2_process_time
                  });
                }
              }
          ).error(
              function (request, error, ex) {
                console.log('PingServer fails: error [' + error + '] ex [' + ex + ']');
                
                cb(error, null);
              }
          );
        },

        PingParallel: function (successFunction, failedFunction) {
          var err_count = 0; //ping-err server
          var success_count = 0;

          checkPointServers.forEach(function (srv) {
            srv.Enabled = false;
            srv.Tries = 0;
            srv.EffectiveTimeOut = 0;

            Shield.PingServer(srv, function (err, obj) {
              if (err) {
                err_count++;
                if ((err_count >= checkPointServers.length) && failedFunction) failedFunction(err); //fired on all failed
              } else {
                console.log(JSON.stringify(obj));

                srv.Enabled = true;
                srv.clientIP = obj.clientIP;
                srv.EffectiveTimeOut = Math.max(+srv.TimeOut, +obj.round_trip_time + obj.max_process_time);
                console.log("srv.EffectiveTimeOut = " + srv.EffectiveTimeOut);
                console.log("success_count = " + success_count);
                success_count++;
                console.log(JSON.stringify(srv));
                if ((success_count == 1) && successFunction) successFunction(srv); //fired on first success
              }
            });
          });
        },

		
        FixError: function (serial, failFunction, successFunction) {
            if(Shield.InActivating) return;

            Shield.InActivating = true;
            _nonce++;
            return Shield.InternalActivate(this.RequestErrorFix(), serial, failFunction, successFunction, Shield.CheckPointActivationType.Unlock);
        },
		
        //Deprecated by FixError()
        Clean: function (serial, failFunction, successFunction) {
          this.FixError(serial, failFunction, successFunction);
        },

        FingerprintFix: function (serial, failFunction, successFunction) {
          this.FixError(serial, failFunction, successFunction);
        },

        Extend : function (serial, failFunction, successFunction) {
          var lic = Shield.GetCurrentLicense();
          var reqCode = gs.util.getAddDurationRequestCode(lic);
          _nonce++;
          return Shield.InternalActivate(reqCode, serial, failFunction, successFunction);
        },
	

        //We are in the process of activating, do not re-activate until this flag becomes false.
        InActivating: false,
        /**
         * Activates a serial
         *
         * @param {String} The serial number to Activate with
         * @param {function} Function to call if the Activation was successful
         * @param {function} Function to call if the Activation was unsuccessful
         */
        Activate: function (serial, failFunction, successFunction) {
            if(Shield.InActivating) return;

            Shield.InActivating = true;
            
            var request = _shield.core.createRequest();
            /* DO NOT need any action here because the SN will fill authorized actions at server side!
            for (var i = 0; i < _shield.core.getTotalEntityCount() ; ++i) {
                var entity = _shield.core.getEntityByIndex(i);

                if (!entity.isFullyLicensed()) {
                    request.addAction(_shield.core.ACT_UNLOCK, entity.getLicenseByIndex(0));
                }
            }*/
            request.addAction(_shield.core.ACT_DUMMY, null);
            var reqCode = request.getRequestCode();
            _nonce++;

            Shield.InternalActivate(reqCode, serial, failFunction, successFunction, Shield.CheckPointActivationType.Unlock);
        },


        //Maximum allowed ping time out, default: 30s
        max_checkpoint2_ping_time_out: 30000,
        //Maximum allowed ajax timeout., default: 1min
        max_checkpoint2_time_out: 60000,
        //Maximum server side process time per request, default: 3s
        max_checkpoint2_process_time: 3000,

        /**
         * Activates a serial (internal)
         *
         * @param {String} The request code
         * @param {String} The serial number to Activate with
         * @param {function} Function to call if the Activation is unsuccessful
         * @param {function} Function to call if the Activation is successful
         * @param {Shield.CheckPointActivationType} the type of action
         * @param {string} (optional) if empty ,use the default GenerateResponseCode. Else call this function on checkpoint
         */

        InternalActivate: function (reqCode, serial, failFunction, successFunction, activationType, checkpointFunction) {
            if (!failFunction) {
                Shield.Log("Shield.InternalActivate: failFunction is not defined!", true)
                return;
            }

            if (!successFunction) {
                Shield.Log("Shield.InternalActivate: successFunction is not defined!", true)
                return;
            }

            function tryGetNextServer() {
              var result = null;
              checkPointServers.forEach(function (srv) {
                if (srv.Enabled && (srv.Tries < srv.MaxTries)) {
                  if (result == null || srv.EffectiveTimeOut < result.EffectiveTimeOut) {
                    result = srv;
                  }
                }
              });

              return result;
            }

            var checkPoint = tryGetNextServer();
            if (checkPoint == null) {
              console.log('Could not connect to Any Activation Server');

              //reset timeout value for later retry (user press "Activate" button after failure)
              checkPointServers.forEach(function(srv){
                  srv.Enabled = true;
                  srv.EffectiveTimeOut = srv.TimeOut;
                  srv.Tries = 0;
              });

              Shield.InActivating = false;

              if (failFunction) {
                  var errorData = {
                      responseCode: 0,
                      message: "Could not connect to any activation server"
                  }

                  failFunction(errorData);
              }
              return;
            }

            console.log("Try activating via server: " + JSON.stringify(checkPoint)); 

            serial = serial.trim();
            var prodId = _shield.productId;
            var buildId = _shield.buildId;

            var data = {
                productID: prodId,
                serialNumber: serial,
                requestCode: reqCode,
                nonce: _nonce,
                BuildId: buildId,
                architecture: gs.os.name
            }

            var checkpointurl = checkPoint.URL;
            if (typeof checkpointFunction !== 'undefined') {
                checkpointurl = checkPoint.URL.replace("GenerateResponseCode", checkpointFunction)
            }

            checkPoint.EffectiveTimeOut = checkPoint.EffectiveTimeOut ? checkPoint.EffectiveTimeOut : checkPoint.TimeOut;

            console.log(JSON.stringify(checkPoint));

            $.ajax({
                url: checkpointurl,
                dataType: "jsonp",
                timeout: checkPoint.EffectiveTimeOut,
                cache: false,
                data: data
            }).success(function (checkPointResponse) {
                console.log(JSON.stringify(checkPointResponse));

		var callFailFunction = true;
		var message = "";
		var retry = false;
		
		if(!checkPointResponse.hasOwnProperty('ResponseCode')){
		    retry = true;
		} else {
			switch (checkPointResponse.ResponseCode) {
			    case Shield.CheckPointResponse.InvalidSerialNumber:
				message = 'Invalid Serial Number';
				break;
			    case Shield.CheckPointResponse.NoActivationsRemaining:
				message = 'No Activations Remaining';
				break;
			    case Shield.CheckPointResponse.InvalidRequestCode:
				message = 'Invalid Request Code';
				break;
			    case Shield.CheckPointResponse.KeyGenError:
				message = 'License Code Generation Error';
				break;
			    case Shield.CheckPointResponse.CodeGenerated:
				callFailFunction = false;
				break;
			    case Shield.CheckPointResponse.FormatOK:
				break;
			    case Shield.CheckPointResponse.CodeBadFormat:
				message = 'Code Bad Format';
				break;
			    case Shield.CheckPointResponse.InternalFailure:
				message = "Internal Server Error";
				retry = true;
				break;
			    case Shield.CheckPointResponse.GetSNFailure:
				//ValididateSerial: Invalid Serial. 
				message = "Serial does not exist on the server."
				break;
			    case Shield.CheckPointResponse.GetSNSuccess:
				callFailFunction = false;
				break;
			    case Shield.CheckPointResponse.InvalidProduct:
				message = "Invalid Product";
				break;
			    case Shield.CheckPointResponse.RevokeReceiptAccepted:
				callFailFunction = false;
				break;
			    case Shield.CheckPointResponse.RevokeInvalidReceipt:
				message = "Invalid Revoke Receipt";
				break;
			    case Shield.CheckPointResponse.RevokeInvalidSerialNumber:
				message = "Invalid serial number";
				break;
			    case Shield.CheckPointResponse.RevokeReactivationToleranceExceeded:
				message = "Reactivation limit Exceeded.";
				break;
			    default:
				message = "There was unknown error";
				retry = true;
				Shield.Log('Shield.InternalActivate: ResponseCode: ' + checkPoint.ResponseCode);
				break;
			}
		}
		
		if(retry){
		  //abnormal server failure, try another server if possible
		  checkPoint.Enabled = false;
                  return Shield.InternalActivate(reqCode, serial, failFunction, successFunction, activationType, checkpointFunction);
		} 

		//checkpoint server result, passed to callback functions
		var result = {
		  sn: serial,
		  snRef: checkPointResponse.SerialNumberReference,
		  responseCode: checkPointResponse.ResponseCode,
		  message: message
		}

                if (callFailFunction) {
                    Shield.Log("Shield.InternalActivate: " + message + ", ResponseCode: " + checkPointResponse.ResponseCode);

                    Shield.InActivating = false;
                    failFunction(result);
                    return;
                } else {
                    var callSuccessFunction = true;
                    switch (activationType) {
                        case Shield.CheckPointActivationType.Unlock:
                            var success = false;
                            if(_shield.core.applyLicenseCodeEx){
                              console.log("applyLicenseCodeEx...");
                              success = _shield.core.applyLicenseCodeEx(checkPointResponse.Result, serial, checkPointResponse.SerialNumberReference);
                            }else{
                              console.log("applyLicenseCode...");
                              success = _shield.core.applyLicenseCode(checkPointResponse.Result); 
                            }

                            if(success){
                                Shield.Log('Shield.InternalActivate: Activated!');
                            } else {
                                callSuccessFunction = false;
                                Shield.Log('Shield.InternalActivate: Failed to Local Activate');
				result.message = _shield.core.getLastErrorMessage();
				Shield.Log('Shield.InternalActivate: ' + result.message, true);
                            }
                            break;
                        case Shield.CheckPointActivationType.Revoke:

                            break;
                        case Shield.CheckPointActivationType.ValidateSN:

                            break;
                        default:
                            Shield.Log('Shield.InternalActivate: Unknown ActivationType')
                            break;
                    }

                    Shield.InActivating = false;
                    
                    if (callSuccessFunction) {
                        successFunction(result);
                    } else {
                        failFunction(result);
                    }
                }
            }).error(function (request, error, ex) {
                Shield.Log('Shield.InternalActivate: Ajax failed error: (' + error + ') + ex (' + ex +'). Server name: ' + checkPoint.Name + ' Attempt: ' + checkPoint.Tries + ' Max Attempts: ' + checkPoint.MaxTries);

                if (error == "timeout") {
                  checkPoint.EffectiveTimeOut *= 2; //double timeout
                  if (checkPoint.EffectiveTimeOut > Shield.max_checkpoint2_time_out) {
                    checkPoint.Enabled = false;
                  } else {
                    checkPoint.Tries++;
                  }
                } else {//"error", "abort", "parsererror"
                  checkPoint.Enabled = false; 
                }

                Shield.InternalActivate(reqCode, serial, failFunction, successFunction, activationType, checkpointFunction);
            });
        },

        /**
         * Activates via offline activation
         * @param {string} the Activation Code generated from the users Activation Requst Code
         *
         * @return {bool} True if Activation is sucessful
         */
        ManualActivate: function (key) {
            Shield.Log('Shield.ManualActivate: LicenseKey; ' + key);
            if (_shield.core.applyLicenseCode(key)) {
                Shield.Log('Shield.ManualActivate:  Manual Activation Success!');
                result = true;
            } else {
                Shield.Log('Shield.ManualActivate: Failed To Local Activate');
                Shield.Log('Shield.ManualActivate: Error code: ' + _shield.core.getLastErrorCode() + " Message: " + _shield.core.getLastErrorMessage(), true);
                result = false;
            }
            return result;
        },

        //Is action option == "Online" in Project settings
        IsOnlineActivationPreferred: function(){
          return _shield.core.isOnlineActivationPreferred();
        },

        InputActivationCode: function (code, success_callback, fail_callback) {
            if (_shield.core.applyLicenseCode(code)) {
                if (success_callback) {
                    success_callback();
                }
            } else {
                if (fail_callback) {
                    fail_callback("Invalid Activation Code");
                }
            }
            return false;
        },

        /**
        * Manual Activation via App-specific Public Web Activator
        * IN
        *    [optional] reqCode: request code, generated via api
        *    [optional] sn: serial number to activate 
        *              If it is not specified, we will try to search for a default one in the following order:
        *              (1) preliminary serial number stored in local license storage;
        *              (2) a session-wide serial number from previous serial number input;
        *
        * OUT
        *    The default web brower is launched to allow end user get license code by himself
        *
        *    The Web activator is useful when the app is blocked by firewall, or the machine
        *    this app is being installed does not have an internet connection.
        */
        WebActivate: function(reqCode, sn){
          var url = "https://checkpoint2manager.yummy.net/Activate/" + gs.productId + "?";
          var serial = sn || gs.core.getPreliminarySN() || gs.sessionData.getVar('serial_number');
          if(serial) url += ("serialNumber=" + serial);
          if(reqCode) url += ("&&requestCode=" + reqCode);

          gs.util.launchDefaultBrowser(url);
        },
        /**
         * Returns the License for the given Entity. If no
         * Entity is given, return the current Entity License.
         *
         *
         * @return {License} The License for the current entity
         */

        GetLicense: function (entity) {
            var lic;
            entity = entity || Shield.Entities.GetCurrentEntity();
            lic = entity.getLicenseByIndex(0);
            return lic;
        },


        Entities: function () {
            return {
                /**
                 * Returns the Current Entity
                 * @return {entity} Current entity in use.
                 */
                GetCurrentEntity: function () {
                    if (_shield.core.getCurrentEntityId() == '(unknown)') {
                        return gs.single.getEntity();
                    } else {
                        return _shield.core.getCurrentEntity();
                    }
                },

                /**
                 * Returns an array of Fully Licensed Entities
                 *
                 * @return {Array} Activated Entities
                 */
                GetActivatedEntities: function () {
                    var entCount = _shield.core.getTotalEntityCount();
                    var entities = [];
                    for (var i = 0; i < entCount; i++) {
                        var ent = _shield.core.getEntityByIndex(i);
                        if (ent.isFullyLicensed()) {
                            entities.push(ent);
                        }
                    }
                    return entities;
                },

                /**
                 * Returns an array of all Entities
                 *
                 *
                 * @return {Array} Array of all Entities
                 */
                GetEntities: function () {
                    var entCount = _shield.core.getTotalEntityCount();
                    var entities = [];
                    for (var i = 0; i < entCount; i++) {
                        entities.push(_shield.core.getEntityByIndex(i));
                    }
                    return entities;
                },

                /**
                 * Returns the number of Entities
                 *
                 *
                 * @return {int} Number of Entities in the project
                 */
                GetTotalEntityCount: function () {
                    return _shield.core.getTotalEntityCount();
                },

                /**
                 * Returns the given entity at index. Null if index does not exit
                 *
                 *
                 * @param {int} Index of the Entity
                 * @return {entity} Entity at index
                 */
                GetEntityByIndex: function (index) {
                    var total = _shield.core.getTotalEntityCount();
                    if (index >= total || index < 0) {
                        Shield.Log("Shield.Entities.GetEntityByIndex: index out of range.");
                        return null;
                    } else {
                        return _shield.core.getEntityByIndex(index);
                    }
                },

                /**
                 * Returns the Unlock Request Code for the given License
                 *
                 *
                 * @param {License} The licnese to get the Unlock Request from
                 * @return {String} The Unlock Request Code
                 */
                GetUnlockRequestCode: function (lic) {
                    //get unlock Request Code for a different License
                    return _shield.util.getUnlockRequestCode(lic);
                },

                /**
                 * Returns the Access Times remaining for the given entity. If
                 * no entity is given, returns Access Times for the current
                 * Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get AccessTimes from (Entity Must be
                 * Expire by Access Times)
                 * @return {int} Amount of Access Times remaining
                 */
                GetAccessTimesRemaining: function (entity) {
                    var lic = Shield.GetLicense(entity);


                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByAccessTimes) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        var max = lic.getParamByName('maxAccessTimes').getValue();
                        var used = lic.getParamByName('usedTimes').getValue();
                        return max - used;
                    }
                },
                /**
                 * Returns the Max Access Times for the given entity. If
                 * no entity is given, returns Max Access Times for the current
                 * Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get AccessTimes from (Entity Must be
                 * Expire by Access Times)
                 * @return {int} Max Access Times
                 */
                GetAccessTimesMax: function (entity) {
                    var lic = Shield.GetLicense(entity);


                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByAccessTimes) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        return lic.getParamByName('maxAccessTimes').getValue();
                    }
                },
                /**
                 * Returns the Access Times used for the given entity. If
                 * no entity is given, returns used Access Times for the current
                 * Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get AccessTimes from (Entity Must be
                 * Expire by Access Times)
                 * @return {int} Used Amount of Access Times
                 */
                GetAccessTimesUsed: function (entity) {
                    var lic = Shield.GetLicense(entity);


                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByAccessTimes) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        return lic.getParamByName('usedTimes').getValue();
                    }
                },

                /**
                 * Returns the Session Time in Minutes for the given entity. If
                 * no entity is given, returns Session Time in Minutes for the current
                 * Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get AccessTimes from (Entity Must be
                 * Expire by Session Time)
                 * @return {int} Session Time in Minutes
                 */
                GetSessionTimeMinutes: function (entity) {
                    var lic = Shield.GetLicense(entity);



                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireBySessionTime) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        var sessionTime = lic.getParamByName('maxSessionTime').getValue();
                        return Math.ceil(sessionTime / 60); //minutes
                    }
                },

                /**
                 * Returns the Session Time in Seconds for the given entity. If
                 * no entity is given, returns Session Time in Seconds for the current
                 * Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get AccessTimes from (Entity Must be
                 * Expire by Session Time)
                 * @return {int} Session Time in Seconds
                 */
                GetSessionTimeSeconds: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireBySessionTime) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        return lic.getParamByName('maxSessionTime').getValue();
                    }
                },

                /**
                 * Returns the TimeBegin paramter of the given entity. If no
                 * Entity is given, return for the current Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get TimeBegin from (Entity Must be
                 * Expire by Hard Date)
                 * @return {UTC Time} Return the 'timeBegin'parameter
                 */
                GetTimeBegin: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByHardDate) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        var startDate = lic.getParamByName('timeBegin').getValue();
                        return startDate; //UTC Time
                    }
                },

                /**
                 * Returns the timeEnd paramter of the given entity. If no
                 * Entity is given, return for the current Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get TimeBegin from (Entity Must be
                 * Expire by Hard Date)
                 * @return {UTC Time} Return the 'timeEnd'parameter
                 */
                GetTimeEnd: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByHardDate) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        var expireDate = lic.getParamByName('timeEnd').getValue();
                        return expireDate; //UTC Time 
                    }
                },

                /**
                 * Returns the periodInSeconds paramter of the given entity. If no
                 * Entity is given, return for the current Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get periodInSeconds from (Entity Must be
                 * Expire by Perido)
                 * @return {int} Return the 'periodInSeconds'parameter
                 */
                GetExpirePeriod: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByPeriod) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        var expirePeriod = lic.getParamByName('periodInSeconds').getValue();
                        return expirePeriod; //Seconds
                    }
                },

                /**
                 * Returns the 'timeFirstAccess' paramter of the given entity. If no
                 * Entity is given, return for the current Entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get timeFirstAccess from (Entity Must be
                 * Expire by Period)
                 * @return {UTC Time} Return the 'timeFirstAccess'parameter
                 */
                GetTimeFirstAccess: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is null');
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByPeriod) {
                        Shield.Log('The entity has the wrong license type. ' + lic.id, true);
                        return null;
                    } else {
                        return lic.getParamByName('timeFirstAccess').getValue(); //UTC Time
                    }


                },

                /**
                 * Returns the Time Remaining in Minutes for the given
                 * Entity. If no Entity is given, returns amount for
                 * the current entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get Time Remaining from (Entity Must be
                 * Expire by Duration)
                 * @return {int} Return the Time Remaining in Minutes
                 */
                GetTimeRemaining: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('Entity License is null.');
                        return null;

                    } else if (lic.id !== Shield.LicenseModel.ExpireByDuration) {
                        Shield.Log('Entity has wrong license!', true);
                        return null;
                    } else {
                        var maxSec = lic.getParamByName("maxDurationInSeconds").getValue();
                        var usedSec = lic.getParamByName("usedDurationInSeconds").getValue();
                        var remainingSeconds = (maxSec - usedSec);
                        return Math.ceil(remainingSeconds / 60); //Minutes
                    }
                },

                /**
                 * Returns the Time Remaining in Seconds for the given
                 * Entity. If no Entity is given, returns amount for
                 * the current entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get Time Remaining from (Entity Must be
                 * Expire by Duration)
                 * @return {int} Return the Time Remaining in Seconds
                 */
                GetTimeRemainingSeconds: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is Null!')
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByDuration) {
                        Shield.Log('Entity has the wrong License!')
                        return null;
                    } else {
                        var maxSec = lic.getParamByName("maxDurationInSeconds").getValue();
                        var usedSec = lic.getParamByName("usedDurationInSeconds").getValue();
                        return (maxSec - usedSec);
                    }
                },

                /**
                 * Returns the total allowed time in Minutes for the given
                 * Entity. If no Entity is given, returns amount for
                 * the current entity
                 *
                 *
                 * @param {Entity} (Optional) Entity to get Time Remaining from (Entity Must be
                 * Expire by Duration)
                 * @return {int} Return the total allowed time in Seconds
                 */
                GetTotalTime: function (entity) {
                    var lic = Shield.GetLicense(entity);
                    if (lic === null) {
                        Shield.Log('License is Null!')
                        return null;
                    } else if (lic.id !== Shield.LicenseModel.ExpireByDuration) {
                        Shield.Log('Entity has the wrong License!')
                        return null;
                    } else {
                        var maxSec = lic.getParamByName("maxDurationInSeconds").getValue();
                        return Math.ceil(maxSec / 60); //Minutes
                    }
                }
            }
        }(),
        /* /Entities */
        Error: function () {
            return {
                /**
                 * Returns the the last Error Code of API calling
                 * @return {int} Error Code
                 */
                GetLastErrorCode: function () {
                  return _shield.core.getLastErrorCode();
                },
                /**
                 * Returns the the last Error Message of API calling
                 * @return {String} Error Message
                 */
                GetLastErrorMessage: function () {
                  return _shield.core.getLastErrorMessage();
                },

                /**
                 * Returns the the last Error Message of Event
                 * @return {String} Error Message
                 */
                GetEventErrorMessage: function () {
                  return _shield.core.getEventErrorMessage();
                },

                //Deprecated
                SetLastErrorMessage: function (message) { },
                //Deprecated
                SetLastErrorCode: function (code) { },

                /**
                * Outputs the debug message to debug log file ( in %HOME%\gs5\*.log )
                */
                debugMsg: function (msg) {
                    _shield.debugMsg(msg);
                },
                ClearLog: function () {
                    $('#log').children().remove();
                }
            }
        }(),
        /* /Error*/
        Segmentation: function () {
            return {
                /**
                 * Set the first Page view time (UTC) for 'page'
                 *
                 * @param {String} page identifier
                 */
                SetFirstPageView: function (page) {
                    if (localStorage && localStorage.getItem(_shield.productId + '_first_' + page) === null) {
                        localStorage.setItem(_shield.productId + '_first_' + page, localStorage.getItem('currentTime'));
                    }
                },

                /**
                 * Get the first Page view time (UTC) for 'page'
                 *
                 * @param {String} page identifier
                 * @return {UTC Time} UTC time of the first page view of 'page'
                 */
                GetFirstPageView: function (page) {
                    return localStorage ? localStorage.getItem(_shield.productId + '_first_' + page) : null;
                },

                /**
                 * Set the last time 'page' was viewd. Usually call on unLoad, before
                 * Shield.Close(), Shield.Play(), etc
                 *
                 * @param {String} page identifier
                 */
                SetLastPageView: function (page) {
                    if(localStorage){
                      var current = new Date();
                      localStorage.setItem('currentTime', current);
                      if (localStorage.getItem(_shield.productId + '_last_' + page) === null) {
                          localStorage.setItem(_shield.productId + '_last_' + page, localStorage.getItem('currentTime'));
                          localStorage.setItem(_shield.productId + '_tempTime_' + page, localStorage.getItem('currentTime'));
                      } else if (localStorage.getItem(_shield.productId + '_last_' + page) == localStorage.getItem(_shield.productId + '_tempTime_' + page)) {
                          localStorage.setItem(_shield.productId + '_tempTime_' + page, localStorage.getItem('currentTime'));
                      } else {
                          localStorage.setItem(_shield.productId + '_last_' + page, localStorage.getItem(_shield.productId + '_tempTime_' + page));
                          localStorage.setItem(_shield.productId + '_tempTime_' + page, localStorage.getItem('currentTime'));
                      }
                    }
                },

                /**
                 * Get the last Page view time (UTC) for 'page'
                 *
                 * @param {String} page identifier
                 * @return {UTC Time} UTC time of the last page view of 'page'
                 */

                GetLastPageView: function (page) {
                    return localStorage ? localStorage.getItem(_shield.productId + '_last_' + page): null;
                },

                /**
                 * Add a page view for 'page'. Usually called on page Load
                 *
                 * @param {String} page identifier
                 */

                AddPageViewCount: function (page) {
                  if(localStorage){
                    if (localStorage.getItem(_shield.productId + '_' + page) == null) {
                        localStorage.setItem(_shield.productId + '_' + page, 1);
                    } else {
                        pageView = localStorage.getItem(_shield.productId + '_' + page);
                        localStorage.setItem(_shield.productId + '_' + page, ++pageView);
                    }
                  }
                },

                /**
                 * Get the page view count for 'page'
                 *
                 * @param {String} page identifier
                 * @return {int} Page view count for 'page'
                 */

                GetPageViewCount: function (page) {
                    return localStorage ? localStorage.getItem(_shield.productId + '_' + page) : 0;
                },

                /**
                 * Set the play for the app. Call when 'onExit' page appears
                 *
                 * @param {String} the page identifier for 'onStart'
                 */

                SetTotalPlayTime: function (introString) {
                    if(localStorage){
                      var current = localStorage.getItem('currentTime');
                      var lastStart = localStorage.getItem(_shield.productId + '_tempTime_' + introString);

                      var session = (current - lastStart);

                      if (localStorage.getItem(_shield.productId + '_playTime') != null) {
                          var previousPlayTime = localStorage.getItem(_shield.productId + '_playTime');
                          var playTime = previousPlayTime + session;

                          localStorage.setItem(_shield.productId + '_playTime', playTime);
                      } else {
                          localStorage.setItem(_shield.productId + '_playTime', session);
                      }
                    }
                },

                /**
                 * Returns the total play time of the app
                 *
                 * @return {UTC Time} seconds of play time
                 */

                GetTotalPlayTime: function () {
                    return localStorage ? localStorage.getItem(_shield.productId + '_playTime_') : 0;
                },

                /**
                 * Add play count. Call before Shield.Play()
                 *
                 */

                AddPlayCount: function () {
                  if(localStorage){
                    if (localStorage.getItem(_shield.productId + '_playCount') == null) {
                        localStorage.setItem(_shield.productId + '_playCount', 1);
                    } else {
                        playCount = localStorage.getItem(_shield.productId + '_playCount');
                        localStorage.setItem(_shield.productId + '_playCount', ++playCount);
                    }
                  }
                },

                /**
                 * Get Play count for app
                 *
                 * @return {int} play count
                 */

                GetPlayCount: function () {
                    return localStorage ? localStorage.getItem(_shield.productId + '_playCount') : 0;
                },

                SetTimeStamp: function () {
                  if(localStorage){
                    var currentTime = new Date();
                    localStorage.setItem('currentTime', currentTime.getTime());
                  }
                },

                GetTimeStamp: function () {
                    return localStorage ? localStorage.getItem('currentTime') : 0;
                },

                ClearLocalStorage: function () {
                  if(localStorage){
                    var length = _shield.productId.length;
                    Object.keys(localStorage).forEach(function (key) {
                        if (key.substring(0, length) === _shield.productId) {
                            localStorage.removeItem(key);
                        }
                    })
                  }
                }
            }
        }() /* /Segmentation */
    }
}()


if (gs.core.isDebugVersion()) {
    Shield.SetDebug(true);
} else {
    Shield.SetDebug(gs.sessionData.getVar('debug'));
}

//Compatible with gameshield.js, so we do not have to maintain two files
jQuery.gameshield = function(options){ };

jQuery.gameshield.__proto__ = Shield;
jQuery.gameshield.GetEntity = Shield.Entities.GetCurrentEntity;
jQuery.gameshield.GetEntityName =  Shield.Entities.GetCurrentEntity().name;
jQuery.gameshield.GetTotalEntityCount = Shield.Entities.GetTotalEntityCount;
jQuery.gameshield.GetEntityByIndex = Shield.Entities.GetEntityByIndex;
jQuery.gameshield.GetUnlockRequestCode = Shield.Entities.GetUnlockRequestCode;

jQuery.gameshield.GetAccessTimesRemaining = Shield.Entities.GetAccessTimesRemaining;
jQuery.gameshield.GetSessionTimeMinutes = Shield.Entities.GetSessionTimeMinutes;
jQuery.gameshield.GetSessionTimeSeconds = Shield.Entities.GetSessionTimeSeconds;
jQuery.gameshield.GetTimeBegin = Shield.Entities.GetTimeBegin;
jQuery.gameshield.GetTimeEnd = Shield.Entities.GetTimeEnd;
jQuery.gameshield.GetExpirePeriod = Shield.Entities.GetExpirePeriod;
jQuery.gameshield.GetTimeFirstAccess = Shield.Entities.GetTimeFirstAccess;

jQuery.gameshield.GetTimeRemaining = Shield.Entities.GetTimeRemaining;
jQuery.gameshield.GetTimeRemainingSeconds = Shield.Entities.GetTimeRemainingSeconds;
jQuery.gameshield.GetTotalTime = Shield.Entities.GetTotalTime;

jQuery.gameshield.GetLastErrorCode = Shield.Error.GetLastErrorCode;
jQuery.gameshield.GetLastErrorMessage = Shield.Error.GetLastErrorMessage;
jQuery.gameshield.debugMsg = Shield.Error.debugMsg;
jQuery.gameshield.ClearLog = Shield.Error.ClearLog;

jQuery.gameshield.SetFirstPageView = Shield.Segmentation.SetFirstPageView;
jQuery.gameshield.GetFirstPageView = Shield.Segmentation.GetFirstPageView;
jQuery.gameshield.SetLastPageView  = Shield.Segmentation.SetLastPageView;
jQuery.gameshield.GetLastPageView  = Shield.Segmentation.GetLastPageView;
jQuery.gameshield.AddPageViewCount =Shield.Segmentation.AddPageViewCount;
jQuery.gameshield.GetPageViewCount =Shield.Segmentation.GetPageViewCount;
jQuery.gameshield.SetTotalPlayTime =Shield.Segmentation.SetTotalPlayTime;
jQuery.gameshield.GetTotalPlayTime =Shield.Segmentation.GetTotalPlayTime;
jQuery.gameshield.AddPlayCount =Shield.Segmentation.AddPlayCount;
jQuery.gameshield.GetPlayCount =Shield.Segmentation.GetPlayCount;
jQuery.gameshield.SetTimeStamp =Shield.Segmentation.SetTimeStamp;
jQuery.gameshield.GetTimeStamp =Shield.Segmentation.GetTimeStamp;
jQuery.gameshield.ClearLocalStorage =Shield.Segmentation.ClearLocalStorage;
